// Package main implements a JUnit XML enhancer that adds file path information to test cases.
package main

import (
	"encoding/xml"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// JUnit XML structures based on gotestsum's internal/junitxml package
// JUnitTestSuites is a collection of JUnit test suites.
type JUnitTestSuites struct {
	XMLName  xml.Name         `xml:"testsuites"`
	Name     string           `xml:"name,attr,omitempty"`
	Tests    int              `xml:"tests,attr"`
	Failures int              `xml:"failures,attr"`
	Errors   int              `xml:"errors,attr"`
	Time     string           `xml:"time,attr"`
	Suites   []JUnitTestSuite `xml:"testsuite"`
}

// JUnitTestSuite is a single JUnit test suite which may contain many testcases.
type JUnitTestSuite struct {
	XMLName    xml.Name        `xml:"testsuite"`
	Tests      int             `xml:"tests,attr"`
	Failures   int             `xml:"failures,attr"`
	Skipped    int             `xml:"skipped,attr,omitempty"`
	Time       string          `xml:"time,attr"`
	Name       string          `xml:"name,attr"`
	Properties []JUnitProperty `xml:"properties>property,omitempty"`
	TestCases  []JUnitTestCase `xml:"testcase"`
	Timestamp  string          `xml:"timestamp,attr"`
}

// JUnitTestCase is a single test case with its result.
type JUnitTestCase struct {
	XMLName     xml.Name          `xml:"testcase"`
	Classname   string            `xml:"classname,attr"`
	Name        string            `xml:"name,attr"`
	Time        string            `xml:"time,attr"`
	File        string            `xml:"file,attr,omitempty"`
	SkipMessage *JUnitSkipMessage `xml:"skipped,omitempty"`
	Failure     *JUnitFailure     `xml:"failure,omitempty"`
}

// JUnitSkipMessage contains the reason why a testcase was skipped.
type JUnitSkipMessage struct {
	Message string `xml:"message,attr"`
}

// JUnitProperty represents a key/value pair used to define properties.
type JUnitProperty struct {
	Name  string `xml:"name,attr"`
	Value string `xml:"value,attr"`
}

// JUnitFailure contains data related to a failed test.
type JUnitFailure struct {
	Message  string `xml:"message,attr"`
	Type     string `xml:"type,attr"`
	Contents string `xml:",chardata"`
}

// processTestCaseFilePath attempts to add file path information to a test case
// Returns true if the test case was matched with a file path (or already had one)
func processTestCaseFilePath(tCase *JUnitTestCase, finder *TestFinder, logger *Logger) bool {
	// Skip if file is already set
	if tCase.File != "" {
		logger.Warning("File already populated for %s. Skipping.", tCase.Name)
		return true
	}

	// Find the test file
	file := finder.FindTestFile(tCase.Classname, tCase.Name)
	if file != "" {
		tCase.File = file
		logger.Debug("Matched: %s -> %s", tCase.Name, file)
		return true
	}

	logger.Warning("Could not find file for test %s in class %s", tCase.Name, tCase.Classname)
	return false
}

func main() {
	var (
		inputFile  = flag.String("input", "", "Path to JUnit XML file")
		outputFile = flag.String("output", "", "Path to output JUnit XML file (defaults to input file)")
		repoRoot   = flag.String("repo-root", ".", "Path to repository root")
		verbose    = flag.Bool("verbose", false, "Enable verbose output for debugging")
	)
	flag.Parse()

	// Initialize logger
	logger := NewLogger(*verbose)

	if *inputFile == "" {
		logger.Fatal("Input file is required")
	}

	if *outputFile == "" {
		*outputFile = *inputFile
	}

	// Read and parse the JUnit XML file
	xmlData, err := os.ReadFile(*inputFile)
	if err != nil {
		logger.Fatal("Failed to read input file: %v", err)
	}

	var testSuites JUnitTestSuites
	if err := xml.Unmarshal(xmlData, &testSuites); err != nil {
		logger.Fatal("Failed to parse XML: %v", err)
	}

	// Initialize test finder and build test map
	finder := NewTestFinder(*repoRoot)
	if err := finder.BuildTestMap(); err != nil {
		logger.Fatal("Failed to build test map: %v", err)
	}

	logger.Debug("Built test map with %d entries", len(finder.testMap))
	logger.Debug("Sample entries:")
	for key, file := range finder.testMap {
		logger.Debug("  %s -> %s", key, file)
	}

	// Process test suites: filter and add file information in one pass
	var (
		shouldFail        = false
		matched           = 0
		total             = 0
		filteredSuites    []JUnitTestSuite
		testLogsOutputDir = filepath.Dir(*outputFile)
	)

	for _, suite := range testSuites.Suites {
		logger.Debug(
			"Processing suite: %s (tests=%d, failures=%d, skipped=%d)",
			suite.Name,
			suite.Tests,
			suite.Failures,
			suite.Skipped,
		)

		var filteredTestCases []JUnitTestCase
		for _, tCase := range suite.TestCases {

			if tCase.Classname == "" && tCase.Name == "TestMain" {
				// TestMain handling. This test case is typically auto-generated by Go and does not correspond to an actual test.
				// So we remove it from the enhanced output.
				logger.Info("Found TestMain test case in suite %s", suite.Name)

				if tCase.Failure == nil {
					continue
				}

				if strings.Contains(tCase.Failure.Contents, "panic: test timed out after") {
					// If a timeout occurs, TestMain it is also reported as failed. So we can filter out this test main failure.
					// However, a timeout may have stopped other tests from even running, meaning they wouldn't be reported in the JUnit XML.
					// So we still mark this case as failure.
					logger.Error(
						"(failing) Timeout detected for %s - %s",
						suite.Name,
						logger.TruncateString(tCase.Failure.Contents, 100),
					)
					shouldFail = true
					continue
				}

				if strings.Contains(tCase.Failure.Contents, "[build failed]") {
					// If a build failure occurred, log and mark as failure
					logger.Error(
						"(failing) Build failure detected for suite %s - %s",
						suite.Name,
						logger.TruncateString(tCase.Failure.Contents, 100),
					)
					shouldFail = true
					continue
				}

				if suite.Tests > 0 && suite.Failures == 0 {
					// Unknown failure in TestMain with no other failures
					logger.Error(
						"(failing) Unknown failure in TestMain with no other failures in suite %s - %s",
						suite.Name,
						logger.TruncateString(tCase.Failure.Contents, 100),
					)
					shouldFail = true
					continue
				}

				logger.Info("Filtering out TestMain failure for suite %s", suite.Name)
				continue
			}

			if tCase.Failure != nil {
				writeRawLogFile(logger, testLogsOutputDir, tCase)
			}

			// Process file information for valid test cases
			total++
			if processTestCaseFilePath(&tCase, finder, logger) {
				matched++
			}

			filteredTestCases = append(filteredTestCases, tCase)
		}
		suite.TestCases = filteredTestCases
		filteredSuites = append(filteredSuites, suite)
	}

	testSuites.Suites = filteredSuites

	// Marshal back to XML
	output, err := xml.MarshalIndent(testSuites, "", "\t")
	if err != nil {
		logger.Fatal("Failed to marshal XML: %v", err)
	}

	// Add XML header
	xmlOutput := []byte(xml.Header + string(output))

	// Write to output file
	err = os.MkdirAll(filepath.Dir(*outputFile), 0700)
	if err != nil {
		logger.Fatal("Failed to create output directory %s: %v", filepath.Dir(*outputFile), err)
	}
	err = os.WriteFile(*outputFile, xmlOutput, 0600)
	if err != nil {
		logger.Fatal("Failed to write output file: %v", err)
	}

	if shouldFail {
		logger.Fatal("JUnit XML enhancement completed with errors. See above logging for details.")
	}

	logger.Info("Successfully enhanced JUnit XML file: %s (%d/%d test cases matched)", *outputFile, matched, total)
}

// writeRawLogFile writes a raw log file for a single failed test for easier debugging by other tools and CI systems
// The file is written to a subdirectory of the base output directory called "raw-test-logs"
func writeRawLogFile(logger *Logger, baseOutputDir string, failingTest JUnitTestCase) {
	if failingTest.Failure == nil {
		return
	}
	if failingTest.Failure.Contents == "" {
		logger.Warning("No failure contents found for test %s to write log file for", failingTest.Name)
		return
	}

	logFile := rawLogFileName(baseOutputDir, failingTest)
	outputDir := filepath.Dir(logFile)

	err := os.MkdirAll(outputDir, 0700)
	if err != nil {
		logger.Error("Failed to create output directory %s: %v", outputDir, err)
		return
	}

	err = os.WriteFile(logFile, []byte(failingTest.Failure.Contents), 0600)
	if err != nil {
		logger.Error("Failed to write log file %s: %v", logFile, err)
		return
	}
	logger.Debug("Wrote log file for test %s to %s", failingTest.Name, logFile)
}

// sanitizeForArtifactFileName ensures a filename is safe for GitHub artifact uploads
// by replacing characters outside of [A-Za-z0-9._-] with underscores and trimming
// leading/trailing spaces or dots which are problematic on some filesystems.
func sanitizeForArtifactFileName(name string) string {
	sanitized := strings.Map(func(r rune) rune {
		switch {
		case r >= 'a' && r <= 'z':
			return r
		case r >= 'A' && r <= 'Z':
			return r
		case r >= '0' && r <= '9':
			return r
		case r == '-', r == '_', r == '.':
			return r
		default:
			return '_'
		}
	}, name)

	// Trim leading/trailing spaces and dots (Windows/Artifact safety)
	sanitized = strings.Trim(sanitized, " .")

	if sanitized == "" {
		return "unnamed"
	}

	// Keep names reasonably short to avoid path length issues in some environments
	if len(sanitized) > 200 {
		sanitized = sanitized[:200]
	}
	return sanitized
}

// rawLogFileName returns the file name for a raw log file for a single failed test
// The file is written to a subdirectory of the base output directory called "raw-test-logs"
func rawLogFileName(baseOutputDir string, failingTest JUnitTestCase) string {
	var (
		outputDir = filepath.Join(baseOutputDir, "raw-test-logs")
		testName  string
	)

	if failingTest.Classname == "" {
		testName = failingTest.Name
	} else {
		shortenedPackageName := filepath.Base(failingTest.Classname)
		testName = fmt.Sprintf("%s.%s", shortenedPackageName, failingTest.Name)
	}

	safeTestName := sanitizeForArtifactFileName(testName)
	return filepath.Join(outputDir, fmt.Sprintf("%s.log", safeTestName))
}
